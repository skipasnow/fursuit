<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Kemono Fursuit Makers</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<link href="https://unpkg.com/tabulator-tables@5.6.0/dist/css/tabulator_midnight.min.css" rel="stylesheet">

<style>
  body {
    background: #2e2e2e;
    color: #fff;
    font-family: sans-serif;
    margin: 0;
    padding: 20px;
    overflow-y: scroll;
  }

  h1 { margin-bottom: 10px; }

  /* --- CONTROLS SECTION --- */
  .controls-container {
    background: #1f1f1f;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    display: flex;
    gap: 15px;
    align-items: center;
    flex-wrap: wrap;
    border: 1px solid #444;
  }

  .control-group {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  select, button {
    padding: 8px 12px;
    border-radius: 4px;
    border: 1px solid #555;
    background: #333;
    color: #fff;
    cursor: pointer;
    font-size: 14px;
  }

  select:hover, button:hover {
    background: #444;
    border-color: darkorange;
  }

  button.reset-btn {
    background: #c62828;
    border-color: #e53935;
  }
  button.reset-btn:hover { background: #d32f2f; }

  label {
    font-weight: bold;
    color: #ccc;
  }

  #creator-table {
    width: 100%;
    margin: auto;
    height: 75vh; 
    border: 1px solid #444;
  }

  /* --- CUSTOM PREVIEW BOXES --- */
  .preview-container {
    display: flex;
    gap: 2px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .preview-box, .logo-box {
    display: inline-block;
    width: 30px;
    height: 30px;
    background-size: cover;
    background-position: center;
    border-radius: 4px;
    cursor: pointer;
    border: 1px solid #555;
    box-sizing: border-box;
  }
  .preview-box:hover, .logo-box:hover {
      border-color: darkorange;
      box-shadow: 0 0 5px rgba(255,140,0,0.5);
  }

  /* --- THE FLOATING TOOLTIP --- */
  #image-tooltip {
    display: none; 
    position: fixed;
    
    width: 400px;
    height: 400px;
    
    background-color: #222;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    border: 2px solid #fff;
    box-shadow: 0 0 20px rgba(0,0,0,0.7);
    z-index: 99999;
    
    pointer-events: none; 
    
    /* ANIMATION BASE STYLES */
    opacity: 0; /* Start hidden */
    /* Use a cubic-bezier for a nice "snap" into place effect */
    transition: opacity 0.25s ease-out, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  }

  .tabulator .tabulator-header { background-color: #1f1f1f !important; }
  a { color: darkorange; text-decoration: none; }
  .tabulator .tabulator-row .tabulator-cell { border: 1px solid #444; }
  .tabulator .tabulator-row:nth-child(even) { background-color: #383838; }
  .tabulator .tabulator-row:nth-child(odd) { background-color: #2e2e2e; }
  
/* --- REACTIVE CELL STYLES --- */
  .tabulator-row .tabulator-cell {
    /* Smooth transition for the tilt reset */
    transition: transform 0.1s ease-out, filter 0.2s ease, box-shadow 0.2s ease;
    /* maintain z-index context */
    position: relative; 
    /* Ensure the background covers the whole tilt area */
    background-clip: padding-box; 
  }

  /* When a cell is active (class added by JS), boost it above others */
  .tabulator-row .tabulator-cell.active-tilt {
    z-index: 1000 !important;
    /* A nice glowing shadow */
    box-shadow: 0 10px 20px rgba(0,0,0,0.5);
    /* Make the borders stand out */
    border-color: #fff !important; 
  }
</style>
</head>
<body>

<h1>Kemono Fursuit Makers</h1>

<div class="controls-container">
  <div class="control-group">
    <label>Quick Sort:</label>
    <select id="sort-field">
      <option value="rank">Rank (Default)</option>
      <option value="price">Price</option>
      <option value="portfolio">Portfolio Size</option>
      <option value="followers">Followers</option>
      <option value="acctAge">Account Age</option>
      <option value="partials">Partials Count</option>
      <option value="fursuits">Fursuits Count</option>
    </select>
  </div>

  <div class="control-group">
    <label>Order:</label>
    <select id="sort-dir">
      <option value="asc">Low to High (Asc)</option>
      <option value="desc">High to Low (Desc)</option>
    </select>
  </div>

  <button id="reset-sort" class="reset-btn">Reset Sort</button>
  
  <div style="margin-left: auto; font-size: 0.9em; color: #aaa; width: 100%; margin-top:10px;">
    *Hold <b>Shift</b> and click column headers to sort by multiple columns at once.
  </div>
</div>

<div id="image-tooltip"></div>
<div id="creator-table"></div>

<script src="https://unpkg.com/tabulator-tables@5.6.0/dist/js/tabulator.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

<script>
const csvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQesC2Kuwk-4S3ID4cCsCvOGM4U0DstvIoewGKQn4pZII8mkoa6fxcN18ozOO3_EkISGIkKNVngLYdN/pub?gid=131139777&single=true&output=csv";

// --- TOOLTIP LOGIC ---
const tooltipEl = document.getElementById("image-tooltip");
let currentPreviewImages = [];
let currentImageIndex = 0;
let slideshowInterval;
let hideTimeout; 
let isTooltipCentered = false; // Track state for animation

function displayImageInTooltip(imageUrl) {
    if (!imageUrl) {
        tooltipEl.style.backgroundImage = 'none';
        return;
    }

    // 1. ANIMATION RESET: Prepare for the incoming image
    // Determine baseline transform based on whether we are centered or not
    const baseTransform = isTooltipCentered ? "translate(-50%, -50%)" : "";
    // Random start angle: -5 or 5 degrees
    const startAngle = Math.random() < 0.5 ? -5 : 5;

    // DISABLE transitions instantly to reset the element without user seeing it snap back
    tooltipEl.style.transition = 'none';
    tooltipEl.style.opacity = '0';
    // Apply the "Twist" and slightly scale down for impact
    tooltipEl.style.transform = `${baseTransform} rotate(${startAngle}deg) scale(0.95)`;

    const img = new Image();
    img.onload = () => {
        // Ensure tooltip is still meant to be visible
        if (tooltipEl.style.display !== 'none') {
            tooltipEl.style.backgroundImage = `url('${imageUrl}')`;
            
            // 2. TRIGGER ANIMATION:
            // Force a browser "Reflow" so it acknowledges the reset state above before animating
            void tooltipEl.offsetWidth; 

            // Re-enable transitions for the smooth effect
            tooltipEl.style.transition = 'opacity 0.25s ease-out, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
            
            // Set Final State: Fully visible, no rotation, full scale
            tooltipEl.style.opacity = '1';
            tooltipEl.style.transform = `${baseTransform} rotate(0deg) scale(1)`;
        }
    };
    img.src = imageUrl;
}

function showTooltip(imageUrls, startIndex = 0) {
    if (!imageUrls || imageUrls.length === 0) {
        hideTooltip();
        return;
    }
    currentPreviewImages = imageUrls;
    currentImageIndex = startIndex;
    
    tooltipEl.style.display = "flex"; 
    displayImageInTooltip(currentPreviewImages[currentImageIndex]);
}

function hideTooltip() {
    clearTimeout(hideTimeout);
    clearInterval(slideshowInterval);

    hideTimeout = setTimeout(() => {
        // On hide, we also fade out
        tooltipEl.style.opacity = '0';
        setTimeout(() => {
             // Wait for fade out before actually hiding display
             if(tooltipEl.style.opacity === '0') {
                 tooltipEl.style.display = "none";
                 tooltipEl.style.backgroundImage = 'none';
                 currentPreviewImages = [];
                 currentImageIndex = 0;
             }
        }, 200); // Match the transition duration
    }, 50);
}

function startSlideshow() {
    clearInterval(slideshowInterval);
    if (currentPreviewImages.length > 1) {
        slideshowInterval = setInterval(() => {
            currentImageIndex = (currentImageIndex + 1) % currentPreviewImages.length;
            displayImageInTooltip(currentPreviewImages[currentImageIndex]);
        }, 2000);
    }
}

// --- POSITIONING LOGIC ---

function centerTooltip() {
    isTooltipCentered = true;
    // Base CSS handles the top/left 50%, but we set size here
    tooltipEl.style.top = "50%";
    tooltipEl.style.left = "50%";
    tooltipEl.style.width = "80vh"; 
    tooltipEl.style.height = "80vh";
    
    // Note: Transform is handled by the animation logic using isTooltipCentered
}

function moveTooltip(e) {
    isTooltipCentered = false;
    const tooltipSize = 200; 
    const offset = 15; 
    const windowHeight = window.innerHeight;
    
    tooltipEl.style.width = tooltipSize + "px";
    tooltipEl.style.height = tooltipSize + "px";

    let left = e.clientX + offset;
    let top = e.clientY + offset;
    
    if (top + tooltipSize > windowHeight) {
        top = e.clientY - tooltipSize - offset;
    }

    tooltipEl.style.left = left + "px";
    tooltipEl.style.top = top + "px";
    
    // Note: Transform rotation is handled by animation logic
}

// --- HELPERS ---
function parseImageFormula(formula) {
  if(!formula) return "";
  const match = formula.match(/=IMAGE\("(.+)"\)/);
  return match ? match[1] : formula;
}

function parsePreviewImages(urlsString) {
    if (!urlsString || typeof urlsString !== 'string') return [];
    return urlsString.split(' ').map(url => url.trim()).filter(url => url !== '');
}

function cleanNumber(val) {
    if (val === null || val === undefined || val === "") return null;
    if (typeof val === 'string') {
        const cleaned = val.replace(/[$,\s]/g, '');
        if(cleaned === "") return null;
        const num = parseFloat(cleaned);
        return isNaN(num) ? null : num;
    }
    return val; 
}

function getGradientColor(value, min, max, lowIsGreen=false){
    if(value === null || value === undefined || value === "" || isNaN(value)) return "";
    const ratio = (value - min)/(max - min);
    const cappedRatio = Math.min(Math.max(ratio,0),1);
    let r,g;
    if(lowIsGreen){
        r = Math.floor(179 * cappedRatio + 46 * (1-cappedRatio)); 
        g = Math.floor(27 * cappedRatio + 111 * (1-cappedRatio)); 
    } else {
        r = Math.floor(46 * cappedRatio + 179 * (1-cappedRatio));
        g = Math.floor(111 * cappedRatio + 27 * (1-cappedRatio));
    }
    return `rgb(${r},${g},0)`;
}

// --- MAIN SCRIPT ---
let table;

Papa.parse(csvUrl, {
    download: true, header: true, dynamicTyping: true,
    complete: function(results) {
        
        const data = results.data.map(row => ({
            rank: cleanNumber(row['Rank']),
            maker: row['Maker'],
            logo: parseImageFormula(row['Logo']),
            makerType: row['Maker Type'],
            link: row['Link'],
            previewImages: parsePreviewImages(row['Preview']), 
            price: cleanNumber(row['$ Price']),
            shipOrFly: cleanNumber(row['$ Ship or Fly']),
            tariff: cleanNumber(row['$ Tariff (2025)']),
            ship: cleanNumber(row['$ Ship']),
            airTravel: cleanNumber(row['$ Air Travel']),
            travelSurplus: cleanNumber(row['$ Travel Surplus']),
            aesthetic: row['Aesthetic'],
            status: row['Status'],
            specialty: row['Specialty'],
            partials: cleanNumber(row['Partials']),
            fursuits: cleanNumber(row['Fursuits']),
            portfolio: cleanNumber(row['Portfolio Size']),
            country: row['Country'],
            followers: cleanNumber(row['Followers']), 
            acctAge: cleanNumber(row['Acct Age']),
            acctDate: row['Acct Date'],
            rep: row['Rep'],
            timeline: row['Timeline'],
            rankScore: cleanNumber(row['Rank Score']),
            imperfections: cleanNumber(row['Imperfections']),
            worksPerYear: cleanNumber(row['Works Per Year']),
            worksRank: cleanNumber(row['Works Rank']),
            followersRank: cleanNumber(row['Followers Rank']),
            acctDateRank: cleanNumber(row['Acct Date Rank']),
            partialsRank: cleanNumber(row['Partials Rank']),
            fursuitsRank: cleanNumber(row['Fursuits Rank']),
            priceRank: cleanNumber(row['Price Rank']),
        })).filter(row => row.maker); 

        if (data.length === 0) {
            console.warn("Data array is empty after mapping.");
            return;
        }

        const colMinMax = {};
        const gradientColumns = ['price','partials','fursuits','portfolio','acctAge','followers'];
        gradientColumns.forEach(col=>{
            const vals = data.map(d=>d[col]).filter(v=>v!==null && v!=="" && !isNaN(v));
            colMinMax[col] = {min: Math.min(...vals), max: Math.max(...vals)};
        });

        table = new Tabulator("#creator-table", {
            data: data,
            layout: "fitData",
            movableColumns: true,
            resizableColumns: true,
            placeholder:"No Data Available",
            height:"75vh", 
            initialSort:[ {column:"rank", dir:"asc"} ],
            
            columns: [
                { title:"Rank", field:"rank", width:80, hozAlign:"center", sorter:"number" },
                { title:"Maker", field:"maker" },
                {
                    title:"Logo", field:"logo", hozAlign:"center", width:60,
                    formatter:function(cell){
                        const val = cell.getValue();
                        return val ? `<div class="logo-box" style="background-image:url('${val}');"></div>` : "";
                    }
                },
                { title:"Maker Type", field:"makerType" },
                {
                    title:"Link", field:"link", formatter:"link", 
                    formatterParams:{ labelField:"link", urlField:"link", target:"_blank" }
                },
                {
                    title: "Preview",
                    field: "previewImages",
                    hozAlign: "center",
                    width: 200,
                    formatter: function(cell) {
                        const imageUrls = cell.getValue();
                        if (!imageUrls || imageUrls.length === 0) return "";
                        
                        const container = document.createElement('div');
                        container.className = 'preview-container';

                        imageUrls.forEach((url, index) => {
                            const previewBox = document.createElement('div');
                            previewBox.className = 'preview-box';
                            previewBox.style.backgroundImage = `url('${url}')`;
                            previewBox.setAttribute('data-image-index', index);
                            container.appendChild(previewBox);
                        });
                        return container;
                    },
                },
                {
                    title:"$ Price", field:"price", hozAlign:"right", sorter:"number",
                    sorterParams:{ alignEmptyValues:"bottom" },
                    formatter:function(cell){
                        const val = cell.getValue();
                        if(val === null) return "N/A"; 
                        const c = getGradientColor(val,colMinMax['price'].min,colMinMax['price'].max,true);
                        cell.getElement().style.backgroundColor = c;
                        cell.getElement().style.color="#fff";
                        return val;
                    }
                },
                { title:"$ Ship or Fly", field:"shipOrFly", hozAlign:"right", sorter:"number", sorterParams:{ alignEmptyValues:"bottom" } },
                { title:"$ Tariff (2025)", field:"tariff", hozAlign:"right", sorter:"number", sorterParams:{ alignEmptyValues:"bottom" } },
                { title:"$ Ship", field:"ship", hozAlign:"right", sorter:"number", sorterParams:{ alignEmptyValues:"bottom" } },
                { title:"$ Air Travel", field:"airTravel", hozAlign:"right", sorter:"number", sorterParams:{ alignEmptyValues:"bottom" } },
                { title:"$ Travel Surplus", field:"travelSurplus", hozAlign:"right", sorter:"number", sorterParams:{ alignEmptyValues:"bottom" } },
                
                { title:"Aesthetic", field:"aesthetic" },
                { title:"Status", field:"status" },
                {
                    title:"Specialty", field:"specialty",
                    headerFilter:"input", headerFilterPlaceholder:"Filter on specialty here..."
                },
                {
                    title:"Partials", field:"partials", hozAlign:"right", sorter:"number",
                    sorterParams:{ alignEmptyValues:"bottom" },
                    formatter:function(cell){
                        const val = cell.getValue();
                        if(val === null) return "";
                        const c = getGradientColor(val,colMinMax['partials'].min,colMinMax['partials'].max,false);
                        cell.getElement().style.backgroundColor = c;
                        cell.getElement().style.color="#fff";
                        return val;
                    }
                },
                {
                    title:"Fursuits", field:"fursuits", hozAlign:"right", sorter:"number",
                    sorterParams:{ alignEmptyValues:"bottom" },
                    formatter:function(cell){
                        const val = cell.getValue();
                        if(val === null) return "";
                        const c = getGradientColor(val,colMinMax['fursuits'].min,colMinMax['fursuits'].max,false);
                        cell.getElement().style.backgroundColor = c;
                        cell.getElement().style.color="#fff";
                        return val;
                    }
                },
                {
                    title:"Portfolio Size", field:"portfolio", hozAlign:"right", sorter:"number",
                    sorterParams:{ alignEmptyValues:"bottom" },
                    formatter:function(cell){
                        const val = cell.getValue();
                        if(val === null) return "";
                        const c = getGradientColor(val,colMinMax['portfolio'].min,colMinMax['portfolio'].max,false);
                        cell.getElement().style.backgroundColor = c;
                        cell.getElement().style.color="#fff";
                        return val;
                    }
                },
                { title:"Country", field:"country" },
                {
                    title:"Followers", field:"followers", hozAlign:"right", sorter:"number",
                    sorterParams:{ alignEmptyValues:"bottom" },
                    formatter:function(cell){
                        const val = cell.getValue();
                        if(val === null) return "";
                        const displayVal = val.toLocaleString(); 
                        const c = getGradientColor(val,colMinMax['followers'].min,colMinMax['followers'].max,false);
                        cell.getElement().style.backgroundColor = c;
                        cell.getElement().style.color="#fff";
                        return displayVal;
                    }
                },
                {
                    title:"Acct Age", field:"acctAge", hozAlign:"right", sorter:"number",
                    sorterParams:{ alignEmptyValues:"bottom" }, 
                    formatter:function(cell){
                        const val = cell.getValue();
                        if(val === null) return "";
                        const c = getGradientColor(val,colMinMax['acctAge'].min,colMinMax['acctAge'].max,false);
                        cell.getElement().style.backgroundColor = c;
                        cell.getElement().style.color="#fff";
                        return val;
                    }
                },
                { title:"Acct Date", field:"acctDate" }
            ],
            rowFormatter:function(row){
                const el = row.getElement();
                if(row.getIndex()%2===0) el.style.backgroundColor="#383838";
                else el.style.backgroundColor="#2e2e2e";
            },
            reactiveData:true, virtualDom:true
        });

        // --- EVENT LISTENERS ---
        document.getElementById("reset-sort").addEventListener("click", function(){
            table.clearSort();
            table.setSort("rank", "asc");
            table.clearHeaderFilter(); 
            document.getElementById("sort-field").value = "rank";
            document.getElementById("sort-dir").value = "asc";
        });

        document.getElementById("sort-field").addEventListener("change", function(){
             const field = this.value;
             const dir = document.getElementById("sort-dir").value;
             table.setSort(field, dir);
        });

        document.getElementById("sort-dir").addEventListener("change", function(){
             const field = document.getElementById("sort-field").value;
             const dir = this.value;
             table.setSort(field, dir);
        });
    }
});

// --- GLOBAL HOVER TRACKING & REACTIVE TILT LOGIC ---
let lastTiltCell = null; // Track the last cell we tilted to reset it

document.addEventListener('mousemove', (e) => {
    const target = e.target;
    const isOverPreview = target.closest('.preview-box');
    const isOverLogo = target.closest('.logo-box'); 
    const isOverTooltip = target.closest('#image-tooltip');
    
    // --- PART 1: REACTIVE CELL TILT ---
    const cell = target.closest('.tabulator-cell');

    // If we moved to a new cell (or out of cells completely), reset the old one
    if (lastTiltCell && lastTiltCell !== cell) {
        lastTiltCell.style.transform = 'none';
        lastTiltCell.style.filter = 'none';
        lastTiltCell.classList.remove('active-tilt');
        lastTiltCell = null;
    }

    if (cell) {
        lastTiltCell = cell;
        cell.classList.add('active-tilt');

        // 1. Calculate dimensions
        const rect = cell.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        // 2. Calculate mouse offset from center
        const mouseX = e.clientX - centerX;
        const mouseY = e.clientY - centerY;

        // 3. Calculate rotation (Max 10 degrees tilt)
        // Note: Rotating X-axis is based on Y-position, and vice versa
        const rotateX = -1 * (mouseY / (rect.height / 2)) * 10; 
        const rotateY = (mouseX / (rect.width / 2)) * 10;

        // 4. Apply 3D Transform
        // perspective(500px) creates the 3D depth. 
        // scale(1.05) pops it slightly toward the user.
        cell.style.transform = `perspective(500px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(1.05)`;
        
        // 5. Apply "Light Up" (Brightness)
        cell.style.filter = "brightness(1.3)";
    }

    // --- PART 2: TOOLTIP & SLIDESHOW LOGIC (Existing) ---
    const sourceBox = isOverPreview || isOverLogo;

    if (sourceBox) {
        // Cancel any pending hide actions immediately
        clearTimeout(hideTimeout);

        const rowEl = target.closest('.tabulator-row');
        
        if (rowEl && table) {
            const row = table.getRow(rowEl);
            if (row) {
                const rowData = row.getData();
                
                let imageUrls = [];
                let index = 0;
                let isLogo = false;

                if (isOverPreview) {
                    imageUrls = rowData.previewImages;
                    index = parseInt(sourceBox.getAttribute('data-image-index'), 10);
                    isLogo = false;
                } else if (isOverLogo) {
                    imageUrls = [rowData.logo];
                    index = 0;
                    isLogo = true;
                }

                if (imageUrls && imageUrls.length > 0) {
                    if (tooltipEl.style.display === 'none' || currentPreviewImages !== imageUrls || currentImageIndex !== index || isLogo) {
                        if (isLogo) {
                            clearInterval(slideshowInterval);
                            moveTooltip(e); 
                            if (tooltipEl.style.display === 'none' || currentPreviewImages !== imageUrls) {
                                showTooltip(imageUrls, index);
                            }
                        } else {
                            clearInterval(slideshowInterval);
                            centerTooltip(); 
                            if (currentPreviewImages !== imageUrls || currentImageIndex !== index) {
                                showTooltip(imageUrls, index);
                            } else {
                                tooltipEl.style.display = "flex";
                            }
                        }
                    }
                }
            }
        }
    } 
    else if (!isOverTooltip && tooltipEl.style.display !== 'none') {
        hideTooltip();
    }
});
// --- END GLOBAL LOGIC ---
</script>

</body>
</html>